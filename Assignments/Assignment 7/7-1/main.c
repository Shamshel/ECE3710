// main.c
// Runs on LM3S1968
 
#include "GPIO.h"
#include "SSI.h"
#include "SYSCTL.h"
#include "GPTM.h"
#include "NVIC.h"
#include "regop.h"

#define DAC (unsigned char*)0x2000C000

volatile unsigned char sin2200Index = 0;
volatile unsigned char sin1700Index = 0;

//generated by MATLAB
volatile float sinArr[64] = {0,-0.099568,-0.19815,-0.29476,-0.38843,-0.47825,-0.56332,-0.64279,-0.71587,-0.78183,-0.84003,-0.88987,-0.93087,-0.96262,-0.98481,-0.9972,-0.99969,-0.99224,-0.97493,-0.94793,-0.91151,-0.86603,-0.81194,-0.74978,-0.68017,-0.6038,-0.52144,-0.43388,-0.34202,-0.24676,-0.14904,-0.049846,0.049846,0.14904,0.24676,0.34202,0.43388,0.52144,0.6038,0.68017,0.74978,0.81194,0.86603,0.91151,0.94793,0.97493,0.99224,0.99969,0.9972,0.98481,0.96262,0.93087,0.88987,0.84003,0.78183,0.71587,0.64279,0.56332,0.47825,0.38843,0.29476,0.19815,0.099568,-1.1838e-12};


int main(void)
{
	//enable clock to timers 0:2
	enableRCGC(RCGC1, 0x070000);
		
	//enable interrupts	
	//enable GPTM0 intA (interrupt 19)
	enableInterrupt(19, 1);
		
	//enable GPTM1 intA (interrupt 21)
	enableInterrupt(21, 1);
			
	//enable GPTM2 intA (interrupt 23, higher priority)
	enableInterrupt(23, 0);
		
	//sin(2pi*1700*t) oscillates at a period of 0.000588 seconds (GPTM0A times out in 0.000588/64 seconds)
	//FREQUENCY*0.000588/64 = 110 clocks
	initGPTMA_Periodic(GPTM0, 110, 1);
		
	//sin(2pi*2200*t) oscillates at a period of 0.000455 seconds (GPTM1A times out in 0.000455/64 seconds)
	//FREQUENCY*0.000455/64 = 85 clocks
	initGPTMA_Periodic(GPTM1, 85, 1);
	
	//combinatorial timeout, should be faster than either of the other two.
	initGPTMA_Periodic(GPTM2, 42, 1);
	
	while(1);		
	
}

void Timer0A_Handler(void)
{
	//clear interrupt
	writeReg(GPTM0, GPTMICR, 0x01);
	
	sin1700Index++;
	
	if(sin1700Index ==64)
	{
		sin1700Index = 0;
		
	}
	
}

void Timer1A_Handler(void)
{
	//clear interrupt
	writeReg(GPTM1, GPTMICR, 0x01);
	
	sin2200Index++;
	
	if(sin2200Index == 64)
	{
		sin2200Index = 0;
		
	}
	
}

void Timer2A_Handler(void)
{
	//clear interrupt
	writeReg(GPTM2, GPTMICR, 0x01);
	
	//add, shift, and scale the sum of the two sin waves, then multiply by the max code to get desired DAC output
	*DAC = (((sinArr[sin1700Index]+sinArr[sin2200Index])+2)/4)*0x3FF; //10-bit DAC
	
}
